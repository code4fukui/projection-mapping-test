<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<body>
<script type="module">
import { THREE, scene, camera, renderer } from "https://code4fukui.github.io/egxr.js/egxr.js";

// シーン、カメラ、レンダラーのセットアップ
camera.position.set(0, 1, 2);

// RenderTargetの作成
const renderTarget = new THREE.WebGLRenderTarget(1024, 1024);

// シーン内に表示するオブジェクト
// 小学校の椅子サイズ
const boxw = 0.36;
const boxd = 0.32;
const boxh = 0.38;
const boxGeometry = new THREE.BoxGeometry(boxw, boxh, boxd);
//const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

const boxMaterial = new THREE.MeshBasicMaterial({
  //color: 0x00ff00,
  map: renderTarget.texture,
});
const nboxes = 5;
const boxr = 1;
for (let i = 0; i < nboxes; i++) {
    const box = new THREE.Mesh(boxGeometry, boxMaterial);
    const th = Math.PI + i * Math.PI / (nboxes - 1);
    const x = Math.cos(th) * boxr;
    const z = Math.sin(th) * boxr;
    box.position.set(x, 0, z);
    box.rotation.y = th;
    scene.add(box);
}

// RenderTarget用のシーンとカメラを用意
const rtScene = new THREE.Scene();
const rtCamera = new THREE.PerspectiveCamera(70, 1, 0.1, 1000);
rtCamera.position.z = 1;
rtScene.add(rtCamera);

// RenderTargetシーンのオブジェクト
/* // box
const rtBoxGeometry = new THREE.BoxGeometry();
const rtBox = new THREE.Mesh(rtBoxGeometry, new THREE.MeshBasicMaterial({
    color: 0xffffff,
}));
rtScene.add(rtBox);
*/
let rtmesh = null;
{
    const geo = new THREE.TorusKnotGeometry(.5, .5 * 0.15, 300, 20, 6, 4);
    const mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        wireframe: true,
    });
    const mesh = new THREE.Mesh(geo, mat);
    rtScene.add(mesh);
    rtmesh = mesh;
}

// アニメーションループ
function animate() {
    // Boxの回転
    //box.rotation.x += 0.01;
    //box.rotation.y += 0.01;
    rtmesh.rotation.x += 0.01;
    rtmesh.rotation.y += 0.01;

    const currentRenderTarget = renderer.getRenderTarget(); // ここで取得

    // RenderTargetにレンダリング
    renderer.setRenderTarget(renderTarget);
    //renderer.setClearColor(0x333333);
    renderer.setClearColor(0x000000);
    renderer.render(rtScene, rtCamera);

    const t = Math.cos(performance.now() / 1000);
    //camera.position.y = 0 + 2 * Math.cos(performance.now() / 1000);
    //plane.rotation.y = performance.now() / 1000;

    // 通常のシーンにレンダリング
    //renderer.setRenderTarget(null);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setClearColor(0x000000);
    renderer.render(scene, camera);
}

renderer.setAnimationLoop(animate);

document.body.onkeydown = (e) => {
    console.log(e);
    if (e.code == "ArrowUp") {
        camera.position.z -= .1;
    } else if (e.code == "ArrowDown") {
        camera.position.z += .1;
    } else if (e.code == "ArrowRight") {
        camera.position.x += .1;
    } else if (e.code == "ArrowLeft") {
        camera.position.x -= .1;
    }
};
document.body.onclick = (e) => {
    if (e.target.tagName == "CANVAS") {
        document.body.requestFullscreen();
        XRButton.style.display = "none";
    }
};
document.addEventListener("fullscreenchange", () => {
    if (!document.fullscreenElement) {
        XRButton.style.display = "block";
    }
});
</script>
</body>
</html>
